cscope 15 /mnt/f/undergraduate_thesis/undergraduate-fzpeng2020/os/src -q 0000000320 0000014402
	@boot/entry.asm

1 .
	g£ùiÚ
 .
	g‹xt
.
	g’Œy


2 .
globl
 
_¡¬t


3 
	g_¡¬t
:

4 
lui
 
¥
, %
	$hi
(
boÙ¡acktİ
è#å°†æ ˆæŒ‡é’ˆ 
¥
 ç½®ä¸ºæ ˆé¡¶åœ°å€

6 
ÿÎ
 
ru¡_maš


8 .
£ùiÚ
 .
bss
.
¡ack


9 .
®ign
 12 #PGSHIFT

10 .
glob®
 
boÙ¡ack


11 
boÙ¡ack
:

12 .
¥aû
 4096 * 4 #å¼€è¾Ÿä¸€å—æ ˆç©ºé—´ï¼ˆ4ä¸ªé¡µï¼‰

13 .
glob®
 
boÙ¡acktİ


14 
boÙ¡acktİ
:

	@clock.rs

1 
u£
 
	gü©e
::
sbi
::
£t_tim”
;

2 
u£
 
	griscv
::::
s›
;

3 
u£
 
	griscv
::::{ 
time
, 
	gtimeh
 };

5 
pub
 
mut
 
	gTICK
: 
usize
 = 0;

6 
	gTIMEBASE
: 
u64
 = 1000;

8 
pub
 
â
 
	$š™
() {

9 
un§ã
 {

10 
TICK
 = 0;

11 
s›
::
	`£t_¡im”
();

13 
	`şock_£t_Ãxt_ev’t
();

14 
´šn
!("++++setupimer !++++");

15 
	}
}

17 
pub
 
â
 
	$şock_£t_Ãxt_ev’t
() {

18 
	`£t_tim”
(
	`g‘_cyşe
(è+ 
TIMEBASE
);

19 
	}
}

21 
â
 
g‘_cyşe
(è-> 
	gu64
 {

22 
	gloİ
 {

23 
Ët
 
	ghi
 = 
timeh
::
»ad
();

24 
Ët
 
	glo
 = 
time
::
»ad
();

25 
Ët
 
	gtmp
 = 
timeh
::
»ad
();

26 
	ghi
 =ğ
tmp
 {

27  ((
hi
 
as
 
u64
è<< 32è| (
lo
‡s u64);

	@consts.rs

1 
pub
 cÚ¡ 
	gPHYSICAL_MEMORY_END
: 
usize
 = 0x80800000;

2 
pub
 cÚ¡ 
	gKERNEL_BEGIN_PADDR
: 
usize
 = 0x80400000;

3 
pub
 cÚ¡ 
	gKERNEL_BEGIN_VADDR
: 
usize
 = 0x80400000;

4 
pub
 cÚ¡ 
	gMAX_PHYSICAL_MEMORY
: 
usize
 = 0x00800000;

5 
pub
 cÚ¡ 
	gMAX_PHYSICAL_PAGES
: 
usize
 = 
MAX_PHYSICAL_MEMORY
 >> 12;

6 
pub
 cÚ¡ 
	gKERNEL_HEAP_SIZE
: 
usize
 = 0x00010000;

	@context.rs

1 
u£
 
	griscv
::::{

2 
s¡©us
::
S¡©us
,

3 
	gsÿu£
::
Sÿu£
,

6 #[
»´
(
C
)]

7 #[
d”ive
(
Debug
)]

8 
pub
 
	sT¿pF¿me
 {

9 
pub
 
	mx
: [
usize
; 32],

10 
pub
 
	ms¡©us
: 
S¡©us
,

11 
pub
 
	m£pc
: 
usize
,

12 
pub
 
	m¡v®
: 
usize
,

13 
pub
 
	msÿu£
: 
Sÿu£
,

	@init.rs

3 
u£
 
	gü©e
::
cÚ¡s
::*;

4 
	gglob®_asm
!(
	gšşude_¡r
!("boot/entry.asm"));

6 
u£
 
	gü©e
::
memÜy
::{

7 
®loc_äame
,

8 
	gd—Îoc_äame


11 #[
no_mªgË
]

12 
pub
 
â
 
ru¡_maš
() -> ! {

14 
â
 
’d
();

16 
´šn
!("rcore_step_by_step os is„unning!", );

17 
	gü©e
::
š‹¼u±
::
š™
();

18 
	g´šn
! (

20 
’d
 
as
 
	gusize
 - 
	gKERNEL_BEGIN_VADDR
 + 
	gKERNEL_BEGIN_PADDR
,

21 
	gPHYSICAL_MEMORY_END


23 
	g´šn
!(

25 ((
’d
 
as
 
	gusize
 - 
	gKERNEL_BEGIN_VADDR
 + 
	gKERNEL_BEGIN_PADDR
) >> 12) + 2,

26 
	gPHYSICAL_MEMORY_END
 >> 12

28 
	gü©e
::
memÜy
::
š™
(

29 ((
’d
 
as
 
usize
 - 
KERNEL_BEGIN_VADDR
 + 
KERNEL_BEGIN_PADDR
) >> 12) + 2,

30 
PHYSICAL_MEMORY_END
 >> 12

32 
dyÇmic_®loÿtšg_‹¡
();

34 
	gü©e
::
şock
::
š™
();

35 
	gun§ã
 {

36 
	gasm
!("ebreak"::::"volatile");

38 
	g·nic
!("end of„ust_main");

39 
	gloİ
 {}

42 
â
 
	$dyÇmic_®loÿtšg_‹¡
() {

43 
u£
 
®loc
::
vec
::
Vec
;

44 
u£
 
®loc
::
boxed
::
Box
;

47 
â
 
	`sbss
();

48 
â
 
	`ebss
();

50 
Ët
 
lbss
 = 
sbss
 
as
 
usize
;

51 
Ët
 
rbss
 = 
ebss
 
as
 
usize
;

53 
Ët
 
h—p_v®ue
 = 
Box
::
	`Ãw
(5);

54 
as£¹
!(*
h—p_v®ue
 == 5);

55 
´šn
!("heap_value‡ssertion successfully!");

56 
´šn
!("h—p_v®ui © {:p}", 
h—p_v®ue
);

57 
Ët
 
h—p_v®ue_addr
 = &*
h—p_v®ue
 
as
 *cÚ¡ 
_
‡ 
usize
;

58 
as£¹
!(
h—p_v®ue_addr
 >ğ
lbss
 && h—p_v®ue_add¸< 
rbss
);

59 
´šn
!("heap_value is in section .bss!");

61 
Ët
 
mut
 
vec
 = 
Vec
::
	`Ãw
();

62 
i
 
š
 0..500 {

63 
vec
.
	`push
(
i
);

65 
i
 
š
 0..500 {

66 
as£¹
!(
vec
[
i
] == i);

68 
´šn
!("vec‡ssertion successfully!");

69 
´šn
!("veøi © {:p}", 
vec
.
	`as_¦iû
());

70 
Ët
 
vec_addr
 = 
vec
.
	`as_±r
(è
as
 
usize
;

71 
as£¹
!(
vec_addr
 >ğ
lbss
 && vec_add¸< 
rbss
);

72 
´šn
!("vec is in section .bss!");

73 
	}
}

	@interrupt.rs

1 
u£
 
	gü©e
::
cÚ‹xt
::
T¿pF¿me
;

2 
u£
 
	griscv
::::{ 
s¡©us
, 
	g¡vec
, 
	gssü©ch
 };

3 
u£
 
	gü©e
::
şock
::{ 
TICK
, 
	gşock_£t_Ãxt_ev’t
};

4 
u£
 
	griscv
::::
sÿu£
::{ 
T¿p
, 
	gExû±iÚ
, 
	gIÁ”ru±
};

6 
	gglob®_asm
!(
	gšşude_¡r
!("trap/trap.asm"));

8 
pub
 
â
 
	$š™
() {

10 
â
 
	`__®É¿ps
();

12 
un§ã
 {

13 
ssü©ch
::
	`wr™e
(0);

14 
¡vec
::
	`wr™e
(
__®É¿ps
 
as
 
usize
, stvec::
T¿pMode
::
Dœeù
);

15 
s¡©us
::
	`£t_s›
();

17 
´šn
!("++++setup interrupt !++++");

18 
	}
}

20 #[
no_mªgË
]

21 
pub
 
â
 
	$ru¡_Œ­
(
tf
: &
mut
 
T¿pF¿me
) {

22 
m©ch
 
tf
.
sÿu£
.
	`ÿu£
() {

23 
T¿p
::
	`Exû±iÚ
(
Exû±iÚ
::
B»akpošt
è=> 
	`b»akpošt
(),

24 
T¿p
::
	`IÁ”ru±
(
IÁ”ru±
::
Su³rvisÜTim”
è=> 
	`su³r_tim”
(),

25 
_
 => 
·nic
!("unexpectedrap"),

27 
	}
}

29 
â
 
	$b»akpošt
() {

30 
·nic
!("a breakpoint set by kernel");

31 
	}
}

33 
â
 
	$su³r_tim”
() {

34 
	`şock_£t_Ãxt_ev’t
();

35 
un§ã
{

36 
TICK
 = TICK + 1;

37 
TICK
 % 10 == 0 {

38 
´šn
!("10icks!");

41 
	}
}

	@io.rs

1 
u£
 
	gü©e
::
sbi
;

2 
u£
 
	gcÜe
::
fmt
::{ 
£lf
, 
	gWr™e
 };

4 
pub
 
â
 
	$putch¬
(
ch
: ) {

5 
sbi
::
	`cÚsŞe_putch¬
(
ch
 
as
 
u8
‡ 
usize
);

6 
	}
}

8 
pub
 
â
 
	$puts
(
s
: &
¡r
) {

9 
ch
 
š
 
s
.
	`ch¬s
() {

10 
	`putch¬
(
ch
);

12 
	}
}

14 
	gStdout
;

16 
im¶
 
	gfmt
::
Wr™e
 
Stdout
 {

17 
â
 
wr™e_¡r
(&
mut
 
£lf
, 
s
: &
¡r
è-> 
fmt
::
ResuÉ
 {

18 
puts
(
s
);

19 
Ok
(())

23 
pub
 
â
 
	$_´št
(
¬gs
: 
fmt
::
Argum’ts
) {

24 
Stdout
.
	`wr™e_fmt
(
¬gs
).
	`unw¿p
();

25 
	}
}

27 #[
maüo_expÜt
]

28 
	gmaüo_ruËs
! 
	g´št
 {

29 (
$
(
$¬g
:
‰
)*) => ({

30 
$ü©e
::
io
::
_´št
(
fÜm©_¬gs
!(
$
(
$¬g
)*));

34 #[
maüo_expÜt
]

35 
	gmaüo_ruËs
! 
	g´šn
 {

36 (è=> (
$ü©e
::
´št
!("\n"));

37 (
$
(
$¬g
:
‰
)*è=> (
$ü©e
::
´št
!("{}\n", 
	gfÜm©_¬gs
!($($arg)*)));

	@lang_items.rs

1 
u£
 
	gcÜe
::
·nic
::
PªicInfo
;

3 #[
·nic_hªdËr
]

4 
â
 
·nic
(
šfo
: &
PªicInfo
) -> ! {

5 
´šn
!("{}", 
	gšfo
);

6 
	gloİ
 {}

9 #[
no_mªgË
]

10 
pub
 "C" 
â
 
	$abÜt
() {

11 
·nic
!("abort!");

12 
	}
}

	@lib.rs

1 #![
no_¡d
]

2 #![
ã©u»
(
asm
)]

3 #![
ã©u»
(
glob®_asm
)]

4 #![
ã©u»
(
®loc_”rÜ_hªdËr
)]

6 
ü©e
 
®loc
;

8 #[
maüo_u£
]

9 
mod
 
	gio
;

10 
mod
 
	gš™
;

11 
mod
 
	gÏng_™ems
;

12 
mod
 
	gsbi
;

13 
mod
 
	gš‹¼u±
;

14 
mod
 
	gcÚ‹xt
;

15 
mod
 
	gşock
;

16 
mod
 
	gcÚ¡s
;

17 
mod
 
	gmemÜy
;

	@main.rs

1 #![
no_¡d
]

2 #![
no_maš
]

4 #[
®low
(
unu£d_impÜts
)]

5 
u£
 
	gos
;

	@memory/frame_allocator.rs

1 
u£
 
	gü©e
::
cÚ¡s
::
MAX_PHYSICAL_PAGES
;

2 
u£
 
	g¥š
::
Mu‹x
;

4 
pub
 
	sSegm’tT»eAÎoÿtÜ
 {

5 
	ma
: [
u8
; 
MAX_PHYSICAL_PAGES
 << 1],

6 
	mm
: 
usize
,

7 
	mn
: 
usize
,

8 
	moff£t
: 
usize


11 
pub
 
SEGMENT_TREE_ALLOCATOR
: 
Mu‹x
<
Segm’tT»eAÎoÿtÜ
> = Mu‹x::
Ãw
(SegmentTreeAllocator {

12 
a
: [0; 
MAX_PHYSICAL_PAGES
 << 1],

13 
m
: 0,

14 
n
: 0,

15 
off£t
: 0

19 
im¶
 
	gSegm’tT»eAÎoÿtÜ
 {

21 
pub
 
â
 
š™
(&
mut
 
£lf
, 
l
: 
usize
, 
r
: usize) {

22 
£lf
.
off£t
 = 
l
 - 1;

23 
	g£lf
.
	gn
 = 
r
 - 
l
;

24 
	g£lf
.
	gm
 = 1;

25 
	g£lf
.
	gm
 < s–f.
	gn
 + 2 {

26 
	g£lf
.
	gm
 = 
£lf
.
m
 << 1;

28 
i
 
š
 (1..(
£lf
.
m
 << 1)è{ 
	g£lf
.
	ga
[i] = 1; }

29 
i
 
š
 (1..
£lf
.
n
è{ 
	g£lf
.
	ga
[£lf.
m
 + i] = 0; }

30 
i
 
š
 (1..
£lf
.
m
).
»v
(è{ 
	g£lf
.
	ga
[i] = s–f.
a
[i << 1] & self.a[(i << 1) | 1]; }

35 
pub
 
â
 
®loc
(&
mut
 
£lf
è-> 
	gusize
 {

37 
	g£lf
.
	ga
[1] == 1 {

38 
·nic
!("physical memory depleted!");

40 
Ët
 
mut
 
	gp
 = 1;

41 
	gp
 < 
	g£lf
.
	gm
 {

42 
	g£lf
.
	ga
[
p
 << 1] =ğ0 {… =… << 1; } { 
	gp
 = (p << 1) | 1; }

44 
Ët
 
	g»suÉ
 = 
p
 + 
£lf
.
off£t
 - s–f.
m
;

45 
	g£lf
.
	ga
[
p
] = 1;

46 
	gp
 >>= 1;

47 
	gp
 > 0 {

48 
	g£lf
.
	ga
[
p
] = 
£lf
.
a
[p << 1] & self.a[(p << 1) | 1];

49 
	gp
 >>= 1;

51 
	g»suÉ


55 
pub
 
â
 
d—Îoc
(&
mut
 
£lf
, 
n
: 
usize
) {

56 
Ët
 
mut
 
p
 = 
n
 + 
£lf
.
m
 - s–f.
off£t
;

57 
	gas£¹
!(
	g£lf
.
	ga
[
p
] == 1);

58 
	g£lf
.
	ga
[
p
] = 0;

59 
	gp
 >>= 1;

60 
	gp
 > 0 {

61 
	g£lf
.
	ga
[
p
] = 
£lf
.
a
[p << 1] & self.a[(p << 1) | 1];

62 
	gp
 >>= 1;

	@memory/mod.rs

1 
mod
 
	gäame_®loÿtÜ
;

3 
u£
 
	gäame_®loÿtÜ
::
SEGMENT_TREE_ALLOCATOR
 
as
 
FRAME_ALLOCATOR
;

4 
u£
 
	griscv
::
addr
::{

8 
VœtAddr
,

9 
	gPhysAddr
,

10 
	gPage
,

11 
	gF¿me


13 
u£
 
	gü©e
::
cÚ¡s
::*;

14 
u£
 
	gbuddy_sy¡em_®loÿtÜ
::
LockedH—p
;

16 
pub
 
â
 
	$š™
(
l
: 
usize
, 
r
: usize) {

17 
FRAME_ALLOCATOR
.
	`lock
().
	`š™
(
l
, 
r
);

18 
	`š™_h—p
();

19 
´šn
!("++++setup memory!++++");

20 
	}
}

22 
â
 
	$š™_h—p
() {

24 
mut
 
HEAP
: [
u8
; 
KERNEL_HEAP_SIZE
] = [0; KERNEL_HEAP_SIZE];

25 
un§ã
 {

27 
DYNAMIC_ALLOCATOR


28 .
	`lock
()

29 .
	`š™
(
HEAP
.
	`as_±r
(è
as
 
usize
, 
KERNEL_HEAP_SIZE
);

31 
	}
}

32 
pub
 
â
 
®loc_äame
(è-> 
	gO±iÚ
<
	gF¿me
> {

34 
Some
(
F¿me
::
of_µn
(
FRAME_ALLOCATOR
.
lock
().
®loc
()))

36 
pub
 
â
 
	$d—Îoc_äame
(
f
: 
F¿me
) {

37 
FRAME_ALLOCATOR
.
	`lock
().
	`d—Îoc
(
f
.
	`numb”
())

38 
	}
}

40 #[
glob®_®loÿtÜ
]

41 
DYNAMIC_ALLOCATOR
: 
LockedH—p
 = LockedH—p::
em±y
();

43 #[
®loc_”rÜ_hªdËr
]

44 
â
 
®loc_”rÜ_hªdËr
(
_
: 
cÜe
::
®loc
::
Layout
) -> ! {

45 
·nic
!("alloc_error_handler do‚othing but…anic!");

	@sbi.rs

1 #![
®low
(
d—d_code
)]

3 #[
šlše
(
®ways
)]

4 
â
 
sbi_ÿÎ
(
which
: 
usize
, 
¬g0
: usize, 
¬g1
: usize, 
¬g2
: usize) -> usize {

5 
Ët
 
»t
;

6 
	gun§ã
 {

7 
	gasm
!("ecall"

8 : "={x10}" (
»t
)

9 : "{x10}" (
¬g0
), "{x11}" (
	g¬g1
), "{x12}" (
	g¬g2
), "{x17}" (
	gwhich
)

13 
	g»t


16 
pub
 
â
 
	$cÚsŞe_putch¬
(
ch
: 
usize
) {

17 
	`sbi_ÿÎ
(
SBI_CONSOLE_PUTCHAR
, 
ch
, 0, 0);

18 
	}
}

20 
pub
 
â
 
cÚsŞe_g‘ch¬
(è-> 
	gusize
 {

21 
sbi_ÿÎ
(
SBI_CONSOLE_GETCHAR
, 0, 0, 0)

24 
pub
 
â
 
	$shutdown
() {

25 
	`sbi_ÿÎ
(
SBI_SHUTDOWN
, 0, 0, 0);

26 
	}
}

28 
pub
 
â
 
	$£t_tim”
(
¡ime_v®ue
: 
u64
) {

29 #[
	`cfg
(
rg‘_poš‹r_width
 = "32")]

30 
	`sbi_ÿÎ
(

31 
SBI_SET_TIMER
,

32 
¡ime_v®ue
 
as
 
usize
,

33 (
¡ime_v®ue
 >> 32è
as
 
usize
,

36 #[
	`cfg
(
rg‘_poš‹r_width
 = "64")]

37 
	`sbi_ÿÎ
(
SBI_SET_TIMER
, 
¡ime_v®ue
 
as
 
usize
, 0, 0);

38 
	}
}

40 
pub
 
â
 
	$ş—r_i
() {

41 
	`sbi_ÿÎ
(
SBI_CLEAR_IPI
, 0, 0, 0);

42 
	}
}

44 
pub
 
â
 
	$£nd_i
(
h¬t_mask
: 
usize
) {

45 
	`sbi_ÿÎ
(
SBI_SEND_IPI
, &
h¬t_mask
 
as
 *cÚ¡ 
_
‡ 
usize
, 0, 0);

46 
	}
}

48 
pub
 
â
 
	$»mÙe_ãnû_i
(
h¬t_mask
: 
usize
) {

49 
	`sbi_ÿÎ
(
SBI_REMOTE_FENCE_I
, &
h¬t_mask
 
as
 *cÚ¡ 
_
‡ 
usize
, 0, 0);

50 
	}
}

52 
pub
 
â
 
	$»mÙe_sãnû_vma
(
h¬t_mask
: 
usize
, 
_¡¬t
: usize, 
_size
: usize) {

53 
	`sbi_ÿÎ
(
SBI_REMOTE_SFENCE_VMA
, &
h¬t_mask
 
as
 *cÚ¡ 
_
‡ 
usize
, 0, 0);

54 
	}
}

56 
pub
 
â
 
	$»mÙe_sãnû_vma_asid
(
h¬t_mask
: 
usize
, 
_¡¬t
: usize, 
_size
: usize, 
_asid
: usize) {

57 
	`sbi_ÿÎ
(

58 
SBI_REMOTE_SFENCE_VMA_ASID
,

59 &
h¬t_mask
 
as
 *cÚ¡ 
_
‡ 
usize
,

63 
	}
}

65 cÚ¡ 
	gSBI_SET_TIMER
: 
usize
 = 0;

66 cÚ¡ 
	gSBI_CONSOLE_PUTCHAR
: 
usize
 = 1;

67 cÚ¡ 
	gSBI_CONSOLE_GETCHAR
: 
usize
 = 2;

68 cÚ¡ 
	gSBI_CLEAR_IPI
: 
usize
 = 3;

69 cÚ¡ 
	gSBI_SEND_IPI
: 
usize
 = 4;

70 cÚ¡ 
	gSBI_REMOTE_FENCE_I
: 
usize
 = 5;

71 cÚ¡ 
	gSBI_REMOTE_SFENCE_VMA
: 
usize
 = 6;

72 cÚ¡ 
	gSBI_REMOTE_SFENCE_VMA_ASID
: 
usize
 = 7;

73 cÚ¡ 
	gSBI_SHUTDOWN
: 
usize
 = 8;

	@trap/trap.asm

1 .
equ
 
	gXLENB
, 4 #å­—é•¿ä¸º 4 
	gBy‹


2 .
maüo
 
LOAD
 
	ga1
, 
	ga2
 #è¯»å–å†…å­˜åœ°å€ 
	g¥
+a2*4 çš„å€¼åˆ°å¯„å­˜å™¨ 
a1


3 
	glw
 \
	ga1
, \
a2
*
XLENB
(
¥
)

4 .
	g’dm


5 .
maüo
 
STORE
 
	ga1
, 
	ga2
 #å°†å¯„å­˜å™¨‡1 çš„å€¼ä¿å­˜åˆ°å†…å­˜åœ°å€ 
	g¥
+a2*4

6 
	gsw
 \
	ga1
, \
a2
*
XLENB
(
¥
)

7 .
	g’dm


9 #ä¸­æ–­ä¹‹å‰æ˜¯
U
æ€åˆ™
ssü©ch
ä¿å­˜çš„æ˜¯å†…æ ¸åœ°å€

10 #ä¸­æ–­ä¹‹å‰æ˜¯
S
æ€åˆ™
ssü©ch
ä¿å­˜çš„æ˜¯0

12 .
maüo
 
	gSAVE_ALL


13 #Ià
comšg
 
äom
 
u£r¥aû
, 
´e£rve
 
the
 
u£r
 
¡ack
 
poš‹r
 
ªd
 
lßd


14 #th
k”Ãl
 
¡ack
 
poš‹r
. 
If
 
we
 
ÿme
 
äom
 
the
 k”Ãl, 
ssü©ch


15 #wÈ
cÚš
 0, 
ªd
 
we
 
should
  
Ú
 
the
 
cu¼’t
 
¡ack
.

16 #åŸå­æŒ‡ä»¤ï¼Œå°†æœ€å³ä¾§çš„
¥
èµ‹å€¼ç»™
ssü©ch


17 #ç„¶åå°†
ssü©ch
èµ‹å€¼ç»™
¥


18 
c¤rw
 
	g¥
, 
	gssü©ch
, 
¥


19 
bÃz
 
	g¥
, 
Œ­_äom_u£r


20 
	gŒ­_äom_k”Ãl
:

21 
c¤r
 
¥
, 
	gssü©ch


22 #ssü©ch = 
´evious
-
¥
, s°ğ
k”Ãl
-sp

23 
	gŒ­_äom_u£r
:

24 #´ovid
room
 
Œ­
 
äame


25 
addi
 
¥
, 
	g¥
, -36*
	gXLENB


26 #§v
x
 
»gi¡”s
 
exû±
 
x2
 (
¥
)

27 
STORE
 
	gx1
, 1

28 
STORE
 
	gx3
, 3

29 
STORE
 
	gx4
, 4

30 
STORE
 
	gx5
, 5

31 
STORE
 
	gx6
, 6

32 
STORE
 
	gx7
, 7

33 
STORE
 
	gx8
, 8

34 
STORE
 
	gx9
, 9

35 
STORE
 
	gx10
, 10

36 
STORE
 
	gx11
, 11

37 
STORE
 
	gx12
, 12

38 
STORE
 
	gx13
, 13

39 
STORE
 
	gx14
, 14

40 
STORE
 
	gx15
, 15

41 
STORE
 
	gx16
, 16

42 
STORE
 
	gx17
, 17

43 
STORE
 
	gx18
, 18

44 
STORE
 
	gx19
, 19

45 
STORE
 
	gx20
, 20

46 
STORE
 
	gx21
, 21

47 
STORE
 
	gx22
, 22

48 
STORE
 
	gx23
, 23

49 
STORE
 
	gx24
, 24

50 
STORE
 
	gx25
, 25

51 
STORE
 
	gx26
, 26

52 
STORE
 
	gx27
, 27

53 
STORE
 
	gx28
, 28

54 
STORE
 
	gx29
, 29

55 
STORE
 
	gx30
, 30

56 
STORE
 
	gx31
, 31

58 #g‘ 
¥
, 
s¡©us
, 
£pc
, 
¡v®
, 
sÿu£


59 #£ˆ
ssü©ch
 = 0

60 
c¤rw
 
	gs0
, 
	gssü©ch
, 
x0


61 
c¤r
 
	gs1
, 
s¡©us


62 
c¤r
 
	gs2
, 
£pc


63 
c¤r
 
	gs3
, 
¡v®


64 
c¤r
 
	gs4
, 
	gsÿu£


65 #¡Ü
¥
, 
s¡©us
, 
£pc
, 
sbadvaddr
, 
sÿu£


66 
STORE
 
	gs0
, 2

67 
STORE
 
	gs1
, 32

68 
STORE
 
	gs2
, 33

69 
STORE
 
	gs3
, 34

70 
STORE
 
	gs4
, 35

71 .
	g’dm


73 .
maüo
 
RESTORE_ALL


74 
LOAD
 
	gs1
, 32 #s1 = 
s¡©us


75 
LOAD
 
s2
, 33 #s2 = 
£pc


76 
ªdi
 
s0
, 
	gs1
, 1 << 8 #s¡©us.
	gSPP
 = 1?

77 
bÃz
 
s0
, 
	g_to_k”Ãl
 #s0 = 
back
 
to
 
k”Ãl
?

78 
_to_u£r
:

79 
addi
 
s0
, 
	g¥
, 36*
XLENB


80 
c¤w
 
	gssü©ch
, 
	gs0
 #ssü©ch = 
k”Ãl
-
¥


81 
_to_k”Ãl
:

82 #»¡Ü
s¡©us
, 
£pc


83 
c¤w
 
	gs¡©us
, 
s1


84 
c¤w
 
	g£pc
, 
	gs2


86 #»¡Ü
x
 
»gi¡”s
 
exû±
 
x2
 (
¥
)

87 
LOAD
 
	gx1
, 1

88 
LOAD
 
	gx3
, 3

89 
LOAD
 
	gx4
, 4

90 
LOAD
 
	gx5
, 5

91 
LOAD
 
	gx6
, 6

92 
LOAD
 
	gx7
, 7

93 
LOAD
 
	gx8
, 8

94 
LOAD
 
	gx9
, 9

95 
LOAD
 
	gx10
, 10

96 
LOAD
 
	gx11
, 11

97 
LOAD
 
	gx12
, 12

98 
LOAD
 
	gx13
, 13

99 
LOAD
 
	gx14
, 14

100 
LOAD
 
	gx15
, 15

101 
LOAD
 
	gx16
, 16

102 
LOAD
 
	gx17
, 17

103 
LOAD
 
	gx18
, 18

104 
LOAD
 
	gx19
, 19

105 
LOAD
 
	gx20
, 20

106 
LOAD
 
	gx21
, 21

107 
LOAD
 
	gx22
, 22

108 
LOAD
 
	gx23
, 23

109 
LOAD
 
	gx24
, 24

110 
LOAD
 
	gx25
, 25

111 
LOAD
 
	gx26
, 26

112 
LOAD
 
	gx27
, 27

113 
LOAD
 
	gx28
, 28

114 
LOAD
 
	gx29
, 29

115 
LOAD
 
	gx30
, 30

116 
LOAD
 
	gx31
, 31

117 #»¡Ü
¥
 
Ï¡


118 
LOAD
 
	gx2
, 2

119 .
	g’dm


123 .
	g£ùiÚ
 .
	g‹xt


124 .
globl
 
__®É¿ps


125 
	g__®É¿ps
:

126 
SAVE_ALL


127 
mv
 
a0
, 
¥


128 
j®
 
	gru¡_Œ­


129 .
globl
 
__Œ­»t


130 
	g__Œ­»t
:

131 
RESTORE_ALL


132 #»tuº 
äom
 
su³rvisÜ
 
ÿÎ


133 
¤‘


	@
1
.
0
14
162
boot/entry.asm
clock.rs
consts.rs
context.rs
init.rs
interrupt.rs
io.rs
lang_items.rs
lib.rs
main.rs
memory/frame_allocator.rs
memory/mod.rs
sbi.rs
trap/trap.asm
